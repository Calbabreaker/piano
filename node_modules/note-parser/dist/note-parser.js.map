{"version":3,"file":null,"sources":["../index.js"],"sourcesContent":["'use strict'\n\n// util\nfunction fillStr (s, num) { return Array(num + 1).join(s) }\nfunction isNum (x) { return typeof x === 'number' }\nfunction isStr (x) { return typeof x === 'string' }\nfunction isDef (x) { return typeof x !== 'undefined' }\nfunction midiToFreq (midi, tuning) {\n  return Math.pow(2, (midi - 69) / 12) * (tuning || 440)\n}\n\nvar REGEX = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)\\s*$/\n/**\n * A regex for matching note strings in scientific notation.\n *\n * @name regex\n * @function\n * @return {RegExp} the regexp used to parse the note name\n *\n * The note string should have the form `letter[accidentals][octave][element]`\n * where:\n *\n * - letter: (Required) is a letter from A to G either upper or lower case\n * - accidentals: (Optional) can be one or more `b` (flats), `#` (sharps) or `x` (double sharps).\n * They can NOT be mixed.\n * - octave: (Optional) a positive or negative integer\n * - element: (Optional) additionally anything after the duration is considered to\n * be the element name (for example: 'C2 dorian')\n *\n * The executed regex contains (by array index):\n *\n * - 0: the complete string\n * - 1: the note letter\n * - 2: the optional accidentals\n * - 3: the optional octave\n * - 4: the rest of the string (trimmed)\n *\n * @example\n * var parser = require('note-parser')\n * parser.regex.exec('c#4')\n * // => ['c#4', 'c', '#', '4', '']\n * parser.regex.exec('c#4 major')\n * // => ['c#4major', 'c', '#', '4', 'major']\n * parser.regex().exec('CMaj7')\n * // => ['CMaj7', 'C', '', '', 'Maj7']\n */\nexport function regex () { return REGEX }\n\nvar SEMITONES = [0, 2, 4, 5, 7, 9, 11]\n/**\n * Parse a note name in scientific notation an return it's components,\n * and some numeric properties including midi number and frequency.\n *\n * @name parse\n * @function\n * @param {String} note - the note string to be parsed\n * @param {Boolean} isTonic - true the strings it's supposed to contain a note number\n * and some category (for example an scale: 'C# major'). It's false by default,\n * but when true, en extra tonicOf property is returned with the category ('major')\n * @param {Float} tunning - The frequency of A4 note to calculate frequencies.\n * By default it 440.\n * @return {Object} the parsed note name or null if not a valid note\n *\n * The parsed note name object will ALWAYS contains:\n * - letter: the uppercase letter of the note\n * - acc: the accidentals of the note (only sharps or flats)\n * - pc: the pitch class (letter + acc)\n * - step: s a numeric representation of the letter. It's an integer from 0 to 6\n * where 0 = C, 1 = D ... 6 = B\n * - alt: a numeric representation of the accidentals. 0 means no alteration,\n * positive numbers are for sharps and negative for flats\n * - chroma: a numeric representation of the pitch class. It's like midi for\n * pitch classes. 0 = C, 1 = C#, 2 = D ... 11 = B. Can be used to find enharmonics\n * since, for example, chroma of 'Cb' and 'B' are both 11\n *\n * If the note has octave, the parser object will contain:\n * - oct: the octave number (as integer)\n * - midi: the midi number\n * - freq: the frequency (using tuning parameter as base)\n *\n * If the parameter `isTonic` is set to true, the parsed object will contain:\n * - tonicOf: the rest of the string that follows note name (left and right trimmed)\n *\n * @example\n * var parse = require('note-parser').parse\n * parse('Cb4')\n * // => { letter: 'C', acc: 'b', pc: 'Cb', step: 0, alt: -1, chroma: -1,\n *         oct: 4, midi: 59, freq: 246.94165062806206 }\n * // if no octave, no midi, no freq\n * parse('fx')\n * // => { letter: 'F', acc: '##', pc: 'F##', step: 3, alt: 2, chroma: 7 })\n */\nexport function parse (str, isTonic, tuning) {\n  if (typeof str !== 'string') return null\n  var m = REGEX.exec(str)\n  if (!m || (!isTonic && m[4])) return null\n\n  var p = { letter: m[1].toUpperCase(), acc: m[2].replace(/x/g, '##') }\n  p.pc = p.letter + p.acc\n  p.step = (p.letter.charCodeAt(0) + 3) % 7\n  p.alt = p.acc[0] === 'b' ? -p.acc.length : p.acc.length\n  var pos = SEMITONES[p.step] + p.alt\n  p.chroma = pos < 0 ? 12 + pos : pos % 12\n  if (m[3]) { // has octave\n    p.oct = +m[3]\n    p.midi = pos + 12 * (p.oct + 1)\n    p.freq = midiToFreq(p.midi, tuning)\n  }\n  if (isTonic) p.tonicOf = m[4]\n  return p\n}\n\nvar LETTERS = 'CDEFGAB'\nfunction accStr (n) { return !isNum(n) ? '' : n < 0 ? fillStr('b', -n) : fillStr('#', n) }\nfunction octStr (n) { return !isNum(n) ? '' : '' + n }\n\n/**\n * Create a string from a parsed object or `step, alteration, octave` parameters\n * @param {Object} obj - the parsed data object\n * @return {String} a note string or null if not valid parameters\n * @since 1.2\n * @example\n * parser.build(parser.parse('cb2')) // => 'Cb2'\n *\n * @example\n * // it accepts (step, alteration, octave) parameters:\n * parser.build(3) // => 'F'\n * parser.build(3, -1) // => 'Fb'\n * parser.build(3, -1, 4) // => 'Fb4'\n */\nexport function build (s, a, o) {\n  if (s === null || typeof s === 'undefined') return null\n  if (s.step) return build(s.step, s.alt, s.oct)\n  if (s < 0 || s > 6) return null\n  return LETTERS.charAt(s) + accStr(a) + octStr(o)\n}\n\n/**\n * Get midi of a note\n *\n * @name midi\n * @function\n * @param {String|Integer} note - the note name or midi number\n * @return {Integer} the midi number of the note or null if not a valid note\n * or the note does NOT contains octave\n * @example\n * var parser = require('note-parser')\n * parser.midi('A4') // => 69\n * parser.midi('A') // => null\n * @example\n * // midi numbers are bypassed (even as strings)\n * parser.midi(60) // => 60\n * parser.midi('60') // => 60\n */\nexport function midi (note) {\n  if ((isNum(note) || isStr(note)) && note >= 0 && note < 128) return +note\n  var p = parse(note)\n  return p && isDef(p.midi) ? p.midi : null\n}\n\n/**\n * Get freq of a note in hertzs (in a well tempered 440Hz A4)\n *\n * @name freq\n * @function\n * @param {String} note - the note name or note midi number\n * @param {String} tuning - (Optional) the A4 frequency (440 by default)\n * @return {Float} the freq of the number if hertzs or null if not valid note\n * @example\n * var parser = require('note-parser')\n * parser.freq('A4') // => 440\n * parser.freq('A') // => null\n * @example\n * // can change tuning (440 by default)\n * parser.freq('A4', 444) // => 444\n * parser.freq('A3', 444) // => 222\n * @example\n * // it accepts midi numbers (as numbers and as strings)\n * parser.freq(69) // => 440\n * parser.freq('69', 442) // => 442\n */\nexport function freq (note, tuning) {\n  var m = midi(note)\n  return m === null ? null : midiToFreq(m, tuning)\n}\n\nexport function letter (src) { return (parse(src) || {}).letter }\nexport function acc (src) { return (parse(src) || {}).acc }\nexport function pc (src) { return (parse(src) || {}).pc }\nexport function step (src) { return (parse(src) || {}).step }\nexport function alt (src) { return (parse(src) || {}).alt }\nexport function chroma (src) { return (parse(src) || {}).chroma }\nexport function oct (src) { return (parse(src) || {}).oct }\n"],"names":["fillStr","s","num","Array","join","isNum","x","isStr","isDef","midiToFreq","midi","tuning","Math","pow","regex","REGEX","parse","str","isTonic","m","exec","p","letter","toUpperCase","acc","replace","pc","step","charCodeAt","alt","length","pos","SEMITONES","chroma","oct","freq","tonicOf","accStr","n","octStr","build","a","o","LETTERS","charAt","note","src"],"mappings":"0MAGA,SAASA,GAASC,EAAGC,GAAO,MAAOC,OAAMD,EAAM,GAAGE,KAAKH,GACvD,QAASI,GAAOC,GAAK,MAAoB,gBAANA,GACnC,QAASC,GAAOD,GAAK,MAAoB,gBAANA,GACnC,QAASE,GAAOF,GAAK,WAAoB,KAANA,EACnC,QAASG,GAAYC,EAAMC,GACzB,MAAOC,MAAKC,IAAI,GAAIH,EAAO,IAAM,KAAOC,GAAU,KAsCpD,QAAgBG,KAAW,MAAOC,GA8ClC,QAAgBC,GAAOC,EAAKC,EAASP,GACnC,GAAmB,gBAARM,GAAkB,MAAO,KACpC,IAAIE,GAAIJ,EAAMK,KAAKH,EACnB,KAAKE,IAAOD,GAAWC,EAAE,GAAK,MAAO,KAErC,IAAIE,IAAMC,OAAQH,EAAE,GAAGI,cAAeC,IAAKL,EAAE,GAAGM,QAAQ,KAAM,MAC9DJ,GAAEK,GAAKL,EAAEC,OAASD,EAAEG,IACpBH,EAAEM,MAAQN,EAAEC,OAAOM,WAAW,GAAK,GAAK,EACxCP,EAAEQ,IAAmB,MAAbR,EAAEG,IAAI,IAAcH,EAAEG,IAAIM,OAAST,EAAEG,IAAIM,MACjD,IAAIC,GAAMC,EAAUX,EAAEM,MAAQN,EAAEQ,GAQhC,OAPAR,GAAEY,OAASF,EAAM,EAAI,GAAKA,EAAMA,EAAM,GAClCZ,EAAE,KACJE,EAAEa,KAAOf,EAAE,GACXE,EAAEX,KAAOqB,EAAM,IAAMV,EAAEa,IAAM,GAC7Bb,EAAEc,KAAO1B,EAAWY,EAAEX,KAAMC,IAE1BO,IAASG,EAAEe,QAAUjB,EAAE,IACpBE,EAIT,QAASgB,GAAQC,GAAK,MAAQjC,GAAMiC,GAAUA,EAAI,EAAItC,EAAQ,KAAMsC,GAAKtC,EAAQ,IAAKsC,GAA7C,GACzC,QAASC,GAAQD,GAAK,MAAQjC,GAAMiC,GAAU,GAAKA,EAAV,GAgBzC,QAAgBE,GAAOvC,EAAGwC,EAAGC,GAC3B,MAAU,QAANzC,OAA2B,KAANA,EAA0B,KAC/CA,EAAE0B,KAAaa,EAAMvC,EAAE0B,KAAM1B,EAAE4B,IAAK5B,EAAEiC,KACtCjC,EAAI,GAAKA,EAAI,EAAU,KACpB0C,EAAQC,OAAO3C,GAAKoC,EAAOI,GAAKF,EAAOG,GAoBhD,QAAgBhC,GAAMmC,GACpB,IAAKxC,EAAMwC,IAAStC,EAAMsC,KAAUA,GAAQ,GAAKA,EAAO,IAAK,OAAQA,CACrE,IAAIxB,GAAIL,EAAM6B,EACd,OAAOxB,IAAKb,EAAMa,EAAEX,MAAQW,EAAEX,KAAO,KAwBvC,QAAgByB,GAAMU,EAAMlC,GAC1B,GAAIQ,GAAIT,EAAKmC,EACb,OAAa,QAAN1B,EAAa,KAAOV,EAAWU,EAAGR,GAG3C,QAAgBW,GAAQwB,GAAO,OAAQ9B,EAAM8B,QAAYxB,OACzD,QAAgBE,GAAKsB,GAAO,OAAQ9B,EAAM8B,QAAYtB,IACtD,QAAgBE,GAAIoB,GAAO,OAAQ9B,EAAM8B,QAAYpB,GACrD,QAAgBC,GAAMmB,GAAO,OAAQ9B,EAAM8B,QAAYnB,KACvD,QAAgBE,GAAKiB,GAAO,OAAQ9B,EAAM8B,QAAYjB,IACtD,QAAgBI,GAAQa,GAAO,OAAQ9B,EAAM8B,QAAYb,OACzD,QAAgBC,GAAKY,GAAO,OAAQ9B,EAAM8B,QAAYZ,IArLtD,GAAInB,GAAQ,oDAqCRiB,GAAa,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAgE/BW,EAAU"}